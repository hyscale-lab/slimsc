#!/bin/bash
#PBS -l {GPU_REQUEST_LINE}
#PBS -l walltime={SERVER_HOURS}:00:00
#PBS -P {PBS_PROJECT}
#PBS -q normal
#PBS -N {JOB_NAME}
#PBS -j oe
#PBS -o {PBS_LOG_FILE}

# --- Shared Setup ---
set -e # Exit immediately if a command exits with a non-zero status.
VLLM_PID=""
EVAL_EXIT_CODE=1 # Default to failure

# --- Cleanup Function ---
cleanup() {{
    echo "[$(date)] Caught signal or exiting, attempting cleanup..."
    # If this is the server node, try to kill the server
    if [[ -n "$VLLM_PID" ]] && ps -p $VLLM_PID > /dev/null; then
        echo "Terminating vLLM server process group (PID: -$VLLM_PID)..."
        kill -TERM -$VLLM_PID &> /dev/null || true
        sleep 5
        if ps -p $VLLM_PID > /dev/null; then
            kill -KILL -$VLLM_PID &> /dev/null || true
        fi
        echo "Server terminated."
    fi

    echo "Cleaning up temporary files..."
    rm -f "{SERVER_IP_FILE}"
    rm -f "{CLIENT_DONE_FILE}"

    if [[ "$EVAL_EXIT_CODE" -eq 0 ]]; then
        echo "Evaluation succeeded (exit code 0). Removing temporary vLLM log."
        rm -f "{VLLM_SERVE_LOG_FILE}"
    else
        echo "Warning: Evaluation failed (exit code: $EVAL_EXIT_CODE). Preserving vLLM log for debugging: {VLLM_SERVE_LOG_FILE}"
    fi

    echo "Cleanup function finished."
}}
trap cleanup SIGINT SIGTERM SIGHUP EXIT

# --- Main Logic ---
echo "--- PBS Job Start ({JOB_NAME}) ---"
echo "Workdir: $PBS_O_WORKDIR"
cd "$PBS_O_WORKDIR" || exit 1
source "{CONDA_INIT_PATH}" && conda activate "{CONDA_ENV_NAME}"

# --- Common Server Setup Logic ---
start_vllm_server() {{
    echo "[$(date)] Setting up and starting vLLM server..."
    # Set the environment variable for the KVC usage file path
    export KVC_USAGE_FILE={TARGET_KVC_FILE_PATH}
    {LD_LIBRARY_EXPORT_COMMAND}
    
    # Ensure the directory for the KVC usage file exists before starting the server
    local kvc_dir
    kvc_dir=$(dirname "$KVC_USAGE_FILE")
    echo "Ensuring KVC usage directory exists: $kvc_dir"
    mkdir -p "$kvc_dir"
    
    PORT_START=$((8000 + ($(echo $PBS_JOBID | cut -d. -f1) % 1000)))
    PORT=$(comm -23 <(seq $PORT_START $((PORT_START+100))) <(ss -tan | awk '{{print $4}}' | cut -d':' -f2 | sort -u) | head -n 1)
    if [ -z "$PORT" ]; then echo "No free port found!"; exit 1; fi
    export PORT
    
    echo "$HOST_IP:$PORT" > "{SERVER_IP_FILE}"
    export VLLM_URL="http://${{HOST_IP}}:${{PORT}}"
    
    echo "Server using CUDA_VISIBLE_DEVICES=$CUDA_VISIBLE_DEVICES"
    echo "Starting vLLM server on $VLLM_URL in background..."
    echo "vLLM will log KV cache usage to: $KVC_USAGE_FILE"
    
    setsid {VLLM_EXEC_COMMAND}
    VLLM_PID=$!
    sleep 5
    if ! ps -p $VLLM_PID > /dev/null; then echo "vLLM server failed to start!"; exit 1; fi
}}

# --- Common Server Wait Logic ---
wait_for_server() {{
    echo "[$(date)] Waiting for server to become ready..."
    local MAX_WAIT_SEC=900; local INTERVAL=30; local elapsed=0
    local SERVER_READY_STRING="Application startup complete."
    while ! grep -qF "$SERVER_READY_STRING" "{VLLM_SERVE_LOG_FILE}"; do
        if ! ps -p $VLLM_PID > /dev/null; then echo "Server process died. Aborting."; exit 1; fi
        if [ $elapsed -ge $MAX_WAIT_SEC ]; then echo "Timeout waiting for server. Aborting."; exit 1; fi
        sleep $INTERVAL; elapsed=$((elapsed + INTERVAL))
        echo "Waited $elapsed/$MAX_WAIT_SEC seconds..."
    done
    echo "[$(date)] Server is ready."
}}

# --- Node-Specific Execution ---
if [ "{IS_MULTI_NODE}" = "true" ]; then
    # ============================
    # ===== MULTI-NODE LOGIC =====
    # ============================
    echo "Multi-node job detected. Parsing node file..."
    SERVER_NODE=$(sort -u $PBS_NODEFILE | head -n 1)
    CLIENT_NODE=$(sort -u $PBS_NODEFILE | tail -n 1)
    if [ "$SERVER_NODE" == "$CLIENT_NODE" ]; then echo "Error: Multi-node job assigned to a single node. Aborting."; exit 1; fi
    echo "Server Node: $SERVER_NODE, Client Node: $CLIENT_NODE"

    export CUDA_VISIBLE_DEVICES="{SERVER_GPU_INDICES}"
    HOST_IP=$(getent hosts "$SERVER_NODE" | awk '{{print $1}}')
    start_vllm_server
    wait_for_server

    echo "[$(date)] Setting up and running evaluation client on $CLIENT_NODE..."
    rm -f "{CLIENT_DONE_FILE}"
    CLIENT_COMMAND=$(cat <<'EOF'
TUNNEL_PID=""
remote_cleanup() {{ echo "[Remote] Cleaning up SSH tunnel..."; if [[ -n "$TUNNEL_PID" ]] && ps -p $TUNNEL_PID > /dev/null; then kill $TUNNEL_PID; fi; }}
trap remote_cleanup EXIT
cd "$PBS_O_WORKDIR"
PROJECT_ROOT_ABS_PATH=$(cd "{PROJECT_ROOT_REL_PATH}" && pwd)
export PYTHONPATH="$PROJECT_ROOT_ABS_PATH:$PYTHONPATH"
source "{CONDA_INIT_PATH}" && conda activate "{CONDA_ENV_NAME}"
SERVER_URL_FULL="{{VLLM_URL_VAR}}"; SERVER_IP_PORT=$(echo "$SERVER_URL_FULL" | sed -e 's%http://%%g'); SERVER_IP=$(echo "$SERVER_IP_PORT" | cut -d: -f1); SERVER_PORT=$(echo "$SERVER_IP_PORT" | cut -d: -f2)
ssh -f -N -L $SERVER_PORT:$SERVER_IP:$SERVER_PORT $SERVER_NODE &
TUNNEL_PID=$!
sleep 2
export VLLM_URL="http://localhost:$SERVER_PORT"
export CUDA_VISIBLE_DEVICES="{CLIENT_GPU_INDICES_MULTI_NODE}"
echo "Client remote execution started on $(hostname)."; echo "Running Evaluation Command: {EVAL_COMMAND}"
{EVAL_COMMAND}
EVAL_EXIT_CODE=$?
echo "[Remote] Client finished with exit code $EVAL_EXIT_CODE. Creating done file."
echo $EVAL_EXIT_CODE > "{CLIENT_DONE_FILE}"
EOF
)
    CLIENT_COMMAND_FILLED="${{CLIENT_COMMAND//'{{VLLM_URL_VAR}}'/$VLLM_URL}}"
    CLIENT_COMMAND_FILLED="${{CLIENT_COMMAND_FILLED//\$SERVER_NODE/$SERVER_NODE}}"
    
    echo "Executing remote client command on $CLIENT_NODE in the background..."
    ssh -o "StrictHostKeyChecking no" "$CLIENT_NODE" "bash -c '$CLIENT_COMMAND_FILLED'" &
    CLIENT_SSH_PID=$!
    
    echo "[$(date)] Main script now waiting for client to finish by polling for the done file..."
    MAX_WAIT_CLIENT_SEC=$(( {SERVER_HOURS} * 3600 - 600 )) 
    INTERVAL=15; elapsed=0
    while [ ! -f "{CLIENT_DONE_FILE}" ]; do
        if ! ps -p $VLLM_PID > /dev/null; then echo "ERROR: vLLM server died while waiting for client. Aborting."; exit 1; fi
        if ! ps -p $CLIENT_SSH_PID > /dev/null; then echo "ERROR: SSH process to client died unexpectedly. Aborting."; exit 1; fi
        if [ $elapsed -ge $MAX_WAIT_CLIENT_SEC ]; then echo "ERROR: Timeout waiting for client to create done file. Aborting."; kill $CLIENT_SSH_PID &> /dev/null || true; exit 1; fi
        sleep $INTERVAL; elapsed=$((elapsed + INTERVAL))
    done

    echo "[$(date)] Client done file found."
    EVAL_EXIT_CODE=$(cat "{CLIENT_DONE_FILE}")
    echo "[$(date)] Remote client evaluation finished with exit code: $EVAL_EXIT_CODE"

    echo "[$(date)] Client has finished. Shutting down vLLM server."
    kill -TERM -$VLLM_PID || true; sleep 5
    if ps -p $VLLM_PID > /dev/null; then kill -KILL -$VLLM_PID &> /dev/null || true; fi
    echo "[$(date)] Server shutdown complete."

else
    # ============================
    # ===== SINGLE-NODE LOGIC ====
    # ============================
    echo "Single-node job detected."
    export CUDA_VISIBLE_DEVICES="{SERVER_GPU_INDICES}"
    HOST_IP=$(getent hosts "$(hostname -s)" | awk '{{print $1}}' || hostname -i)
    start_vllm_server
    wait_for_server

    echo "[$(date)] Setting up and running evaluation client..."
    cd "{PROJECT_ROOT_REL_PATH}" || exit 1
    if [ "{EVAL_TYPE}" = "similarity" ]; then
        export CUDA_VISIBLE_DEVICES="{CLIENT_GPU_INDICES_SINGLE_NODE}"
        echo "Client using CUDA_VISIBLE_DEVICES=$CUDA_VISIBLE_DEVICES"
    else
        echo "Client using available CPUs."
    fi
    echo "Running Evaluation Command: {EVAL_COMMAND}"
    {EVAL_COMMAND}
    EVAL_EXIT_CODE=$?
fi

echo "[$(date)] Evaluation script exited with code: $EVAL_EXIT_CODE"
echo "--- PBS Job Finished ---"
exit $EVAL_EXIT_CODE